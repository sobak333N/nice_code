
C.mro()=[<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>]
E.mro()=[<class '__main__.E'>, <class '__main__.B'>, <class '__main__.A'>, <class '__main__.D'>, <class 'abc.ABC'>, <class 'object'>]
[<class '__main__.Final'>, <class '__main__.C'>, <class '__main__.E'>, <class '__main__.B'>, <class '__main__.A'>, <class '__main__.D'>, <class 'abc.ABC'>, <class 'object'>]
[<class '__main__.Final'>, <class '__main__.E'>, <class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class '__main__.D'>, <class 'abc.ABC'>, <class 'object'>]
sobak3n@sobak3n-desktop:/media/sobak3n/stud/code/python/fastapi_proj$ 

A тоже общий узел
ChatGPT said:
ChatGPT

Спасибо за уточнение! Давайте разберём подробно, как общий узел A учитывается в порядке MRO (Method Resolution Order) и почему он добавляется только один раз, как и другие общие узлы (например, B).
MRO каждого из классов:
MRO C:

C.mro() = [<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>]

    C наследуется от B, а B от A.
    Все классы добавляются в порядке прямой цепочки наследования.

MRO E:

E.mro() = [<class '__main__.E'>, <class '__main__.B'>, <class '__main__.A'>, <class '__main__.D'>, <class 'abc.ABC'>, <class 'object'>]

    E наследуется от B, который наследуется от A, а также напрямую от D, который наследуется от abc.ABC.

Что происходит при создании Final?
Пример 1: Final(C, E)
Порядок объединения:

    Начинаем с первого родителя (C):

[C, B, A, object]

Добавляем второй родитель (E) так, чтобы он был совместим с текущей цепочкой:

    [E, B, A, D, ABC, object]

Итоговое объединение (по C3-линеаризации):

    Берём первый элемент из C, который ещё не добавлен: C.
    Берём первый элемент из E, который ещё не добавлен: E.
    Далее смотрим на общие узлы:
        B встречается в обеих MRO (C и E), добавляется только один раз.
        A также встречается в обеих MRO, добавляется только один раз.
    После этого добавляем остальные элементы из E:
        D, ABC, object.

Итоговая MRO:

[<class '__main__.Final'>, <class '__main__.C'>, <class '__main__.E'>, <class '__main__.B'>, <class '__main__.A'>, <class '__main__.D'>, <class 'abc.ABC'>, <class 'object'>]

Пример 2: Final(E, C)
Порядок объединения:

    Начинаем с первого родителя (E):

[E, B, A, D, ABC, object]

Добавляем второй родитель (C) так, чтобы он был совместим с текущей цепочкой:

    [C, B, A, object]

Итоговое объединение (по C3-линеаризации):

    Берём первый элемент из E, который ещё не добавлен: E.
    Берём первый элемент из C, который ещё не добавлен: C.
    Далее смотрим на общие узлы:
        B встречается в обеих MRO (C и E), добавляется только один раз.
        A также встречается в обеих MRO, добавляется только один раз.
    После этого добавляем остальные элементы из E:
        D, ABC, object.

Итоговая MRO:

[<class '__main__.Final'>, <class '__main__.E'>, <class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class '__main__.D'>, <class 'abc.ABC'>, <class 'object'>]

Почему A добавляется только один раз?

A — это общий узел, встречающийся в обеих цепочках наследования (C и E).

Алгоритм C3-линеаризации гарантирует:

    Каждый класс добавляется в MRO только один раз.
        Это предотвращает повторяющиеся вызовы методов, если они определены в общем классе.
    A добавляется после всех его наследников.
        B (потомок A) добавляется в MRO раньше, чем A.

Общие правила для общих узлов

    Общие классы добавляются только один раз.
        Это касается всех классов, включая A, B, D, и даже встроенных классов, таких как object.

    Общие узлы добавляются в MRO после их наследников.
        Например, A добавляется после B, так как B наследуется от A.

    Алгоритм C3-линеаризации гарантирует совместимость.
        Если несколько классов наследуются от одного общего узла, он включается в MRO ровно один раз и только после того, как все его наследники уже добавлены.

Итоговый вывод:
Для Final(C, E):

    Начинается с C, затем добавляется E.
    Общие узлы (B и A) добавляются только один раз.
    D, ABC, и object добавляются после, так как они уникальны для E.

Для Final(E, C):

    Начинается с E, затем добавляется C.
    Общие узлы (B и A) остаются уникальными и добавляются только один раз.
    Остальные узлы добавляются в порядке, определённом алгоритмом.

Основной фактор — порядок наследования в определении класса Final, который определяет приоритет обработки родителей (C или E) в MRO.