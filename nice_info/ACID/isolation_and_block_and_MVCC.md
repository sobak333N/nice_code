Ниже собран **полный отчёт** (конспект) по **уровням изоляции**, **блокировкам** и **MVCC** в **PostgreSQL (версии 15)**, включая различные **аномалии**, **типы блокировок** и **их влияние** на операции в транзакциях. Материал структурирован, чтобы служить справочным пособием и объяснением того, как PostgreSQL управляет параллельным доступом к данным.

---

# 1. MVCC (Multiversion Concurrency Control)

**Multiversion Concurrency Control (MVCC)** — механизм PostgreSQL, позволяющий параллельно обрабатывать множество транзакций, минимизируя блокировки при чтении.  
- При каждом **изменении строки** создаётся **новая версия** (tuple).  
- **Транзакции** видят только те версии строк, которые были **зафиксированы (commit)** до момента их «снимка» (snapshot).  
- **Снимок** (snapshot) обычно берётся при первом чтении данных внутри транзакции (lazy snapshot creation).

**Ключевые атрибуты** каждой строки:
- `xmin` — идентификатор транзакции, создавшей строку.
- `xmax` — идентификатор транзакции, удалившей/изменившей строку (если строка ещё «жива», `xmax = 0` или `NULL`).

**Преимущества MVCC**:
1. **Высокая производительность** при параллельном чтении и записи.
2. **Чтения не блокируют записи** и наоборот, большая часть SELECT-ов выполняется без блокировок.
3. **Соответствие ACID** — обеспечивает атомарность и изоляцию транзакций.

---

# 2. Уровни изоляции транзакций

По стандарту SQL, есть 4 уровня: **Read Uncommitted**, **Read Committed**, **Repeatable Read**, **Serializable**.  
Однако в **PostgreSQL**:

1. **Read Uncommitted** обрабатывается как **Read Committed**.
2. **Read Committed** — **уровень по умолчанию**.
3. **Repeatable Read** — эквивалент «Snapshot Isolation» (нет фантомных чтений в классическом виде).
4. **Serializable** — самый строгий, может приводить к ошибке `serialization_failure` при конфликте диапазонов.

## 2.1 Read Uncommitted (в PostgreSQL = Read Committed)

- **Общее поведение (в PG = Read Committed):**  
  - Каждая команда внутри транзакции видит только **зафиксированные** изменения, сделанные **до начала** данной команды (не всей транзакции).  
  - При `SELECT` обычном **нет** блокировок; при `UPDATE/DELETE` PostgreSQL ставит **row-level lock**.

- **Аномалии**:  
  - Могут происходить **неповторяемые чтения** и **фантомные чтения**.  
  - «Грязное чтение» (dirty read) в PostgreSQL отсутствует даже в «Read Uncommitted», так как PG реально использует «Read Committed».

## 2.2 Read Committed

- **Стандартный уровень PostgreSQL**:
  - **Каждая команда** (SELECT, UPDATE и т. д.) видит **зафиксированные** изменения на момент начала этой команды.
  - Если другая транзакция обновит/зафиксирует данные до момента **выполнения** вашей команды, вы увидите эти изменения.

- **Аномалии**:
  - **Неповторяемое чтение**: Если вы дважды выполнили `SELECT` в одной транзакции, а параллельная транзакция изменила данные и зафиксировала, вы можете получить разные результаты.
  - **Фантомное чтение**: Вставленные параллельной транзакцией строки также могут «всплывать» при повторном запросе.

## 2.3 Repeatable Read

- **Поведение (Snapshot Isolation):**  
  - Первый запрос внутри транзакции берёт «снимок» всей базы, а все последующие запросы **видят одни и те же версии** строк.  
  - Изменения, зафиксированные другими транзакциями **после** того, как ваша транзакция «сделала» первый запрос, вам не видны.
  
- **Аномалии** (по стандарту SQL — фантомы возможны), **но в PostgreSQL**:
  - **Фантомные чтения** практически устранены, так как новая строка не становится видимой «на лету».  
  - При повторном чтении того же диапазона вы не увидите новодобавленных строк; **ошибки** не случается, вы просто не замечаете чужие изменения.

- **Сценарий**:
  - Если транзакция T1 на Repeatable Read прочла «диапазон», а T2 вставила новую строку в этот диапазон, **T1** всё равно не увидит новинку, но **и не получит ошибки**.  
  - Поведение называется «Snapshot Isolation».

## 2.4 Serializable

- **Самый строгий уровень**:
  - PostgreSQL пытается гарантировать, что результат будет **эквивалентен** последовательному выполнению транзакций.
  - Если обнаружится конфликт (например, одна транзакция читала диапазон, а другая вставила строку в этот диапазон, что *логически* меняет ожидаемый результат), Postgres выбрасывает ошибку `serialization_failure`.

- **Типичный пример**:  
  - T1: `SELECT SUM(...) FROM table WHERE condition;`  
  - T2: `INSERT ... (подходящую под condition)`, `COMMIT`;  
  - T1: повторный `SELECT ...` — при **Serializable** может привести к `serialization_failure`.

- **Итог**:  
  - Придётся **повторять** транзакцию T1 после ошибки.

---

### Сводная таблица аномалий и уровней изоляции

| Уровень                  | Грязное чтение | Неповторяемое чтение | Фантомное чтение | В PostgreSQL |
|--------------------------|----------------|-----------------------|------------------|-------------|
| Read Uncommitted*        | Допускается*   | Допускается          | Допускается      | *Не используется; фактически = Read Committed* |
| Read Committed (по умолчанию) | **Нет**        | **Возможны**         | **Возможны**     | Да          |
| Repeatable Read          | **Нет**        | **Нет** (по PG)      | Нет*            | Да, Snapshot Isolation |
| Serializable             | **Нет**        | **Нет**              | **Нет**          | Да, при конфликте ошибка |

> Примечание:  
> - Грязное чтение (Dirty Read) в PostgreSQL отсутствует даже в «Read Uncommitted».  
> - Фантомное чтение в PostgreSQL на уровне Repeatable Read фактически не происходит (Snapshot Isolation).  
> - В Serializable при конфликтах выдаётся `serialization_failure`.

---

# 3. Блокировки в PostgreSQL

**Блокировки** — механизм, гарантирующий целостность данных при параллельной работе транзакций. В PostgreSQL есть **row-level** и **table-level** блокировки.  

## 3.1 Row-level locks

- **Row Exclusive Lock**:  
  - Устанавливается при `UPDATE`, `DELETE`, `SELECT ... FOR UPDATE` и `SELECT ... FOR NO KEY UPDATE`.  
  - Запрещает другим транзакциям модифицировать те же строки.  

- **Row Share Lock**:  
  - Используется `SELECT ... FOR SHARE`.  
  - Запрещает другие операции, которые меняют данные (UPDATE, DELETE), но позволяет читать.  

- **No Lock** (обычный `SELECT` без FOR UPDATE):  
  - Не блокирует строку для других транзакций (только в рамках MVCC).  

## 3.2 Table-level locks

- **Access Exclusive** (например, `ALTER TABLE`, `TRUNCATE`):  
  - Полная блокировка таблицы.  

- **Access Share** (обычный `SELECT`):  
  - Несколько транзакций могут читать одновременно.  

> PostgreSQL стремится в большинстве случаев использовать **row-level lock**, минимизируя блокировки на всю таблицу.

---

# 4. Какие операции со строкой запрещены при разных блокировках

Ниже краткая таблица по **операциям** и **типу блокировок**:

| **Операция**                     | **Тип блокировки**         | **Запрещённые действия другими транзакциями**                          |
|----------------------------------|----------------------------|-----------------------------------------------------------------------|
| `SELECT (без FOR UPDATE/SHARE)` | **No Lock**                | Нет ограничений (другие могут свободно читать и писать).             |
| `SELECT ... FOR SHARE`          | **Row Share Lock**         | `UPDATE`, `DELETE` (и другие блокировки Exclusive) над теми же строками. |
| `SELECT ... FOR UPDATE`         | **Row Exclusive Lock**     | `UPDATE`, `DELETE`, `SELECT ... FOR UPDATE` (второй раз) над теми же строками. |
| `SELECT ... FOR NO KEY UPDATE`  | **Row Exclusive Lock**     | Изменение уникальных ключей (строка «занята»).                       |
| `UPDATE` / `DELETE`             | **Row Exclusive Lock**     | Любая запись или запрос с `FOR UPDATE` к тем же строкам.             |
| `INSERT` (новая строка)         | **Row Exclusive Lock** для новой строки | Другие транзакции не могут модифицировать **вставленную строку**, пока транзакция не завершится. |

---

# 5. Пример отличий Repeatable Read и Serializable

### Сценарий «Фантомная вставка в диапазон»

1. **Repeatable Read**  
   - T1 делает `SELECT SUM(price) FROM orders WHERE product_id <= 5;` (получает, скажем, 60).  
   - T2 `INSERT ... (3, 40); COMMIT;`  
   - T1 при повторном `SELECT` видит тот же снимок (60), **без ошибки**.  

2. **Serializable**  
   - Те же шаги: T1 читала диапазон `(<=5)`, T2 вставила `(product_id=3)` — конфликт.  
   - При `COMMIT` или втором `SELECT` T1 получит **`serialization_failure`**.  

---

# 6. Наглядная сводка

## 6.1 Уровни изоляции (PostgreSQL 15)

| **Уровень**       | **Основная идея**                                                  | **Аномалии**                                  | **Поведение**                                                                                   |
|-------------------|--------------------------------------------------------------------|-----------------------------------------------|-------------------------------------------------------------------------------------------------|
| Read Uncommitted  | = Read Committed в PostgreSQL                                      | (По стандарту: грязные чтения, фантомы)       | В PG не используется как отдельный, фактически Read Committed. 
                                 |
| **Read Committed** (по умолчанию) | Каждая команда видит зафиксированные изменения на момент начала команды. | Неповторяемое и фантомное чтение **возможны** | Типичная ситуация: повторный SELECT может дать другой результат, если другая транзакция зафикcировала изменение. |

| **Repeatable Read** (Snapshot Isolation) | «Снимок» данных фиксируется при первом чтении, все запросы видят одну и ту же версию. | По стандарту фантомы возможны, **в PG** — нет | При повторном SELECT в одной транзакции вы увидите те же самые строки (другие изменения скрыты).                |

| **Serializable**  | Иллюзия последовательного выполнения транзакций.                  | Ошибка `serialization_failure` при конфликте  | Фантомы или искажения данных приводят к ошибке, транзакцию нужно **повторить**.                                |

## 6.2 Типы блокировок и их влияние

| **Тип операции**                     | **Тип блокировки**        | **Запрещённые действия**                                                             |
|--------------------------------------|---------------------------|--------------------------------------------------------------------------------------|
| `SELECT (без FOR)`                   | Нет блокировки (No Lock)  | Нет ограничений (другие транзакции могут читать/писать эти строки).                 |
| `SELECT ... FOR SHARE`               | Row Share Lock            | Запрещён `UPDATE/DELETE` над теми же строками.                                       |
| `SELECT ... FOR UPDATE`              | Row Exclusive Lock        | Запрещены параллельные `UPDATE/DELETE` (а также второй `SELECT ... FOR UPDATE`).      |
| `SELECT ... FOR NO KEY UPDATE`       | Row Exclusive Lock        | Нельзя менять уникальный ключ в параллельных транзакциях для тех же строк.          |
| `UPDATE` / `DELETE`                  | Row Exclusive Lock        | Запрещены параллельные изменения тех же строк или `FOR UPDATE` над ними.            |
| `INSERT` (новая строка)             | Row Exclusive (нов. стр.) | Пока транзакция не завершится, никто не может изменить вставленную строку.          |
| `ALTER TABLE`, `TRUNCATE`, ...       | Access Exclusive          | Таблица полностью блокируется для любых операций.                                   |

---

# 7. Заключение и рекомендации

1. **Выбор уровня изоляции**:
   - **Read Committed** (по умолчанию) достаточен для большинства OLTP-приложений, так как он быстрее и реже вызывает конфликты.
   - **Repeatable Read** защищает от неповторяемого чтения, **в PostgreSQL** фактически нет фантомов.
   - **Serializable** применяют для особо критичных сценариев, где нужна полная логическая согласованность, но возможны частые `serialization_failure`.

2. **Управление блокировками**:
   - **Держите транзакции короткими**: уменьшаете вероятность конфликтов и блокировок.
   - Если нужно заранее «зарезервировать» строку для изменения, используйте `SELECT ... FOR UPDATE`.
   - Мониторьте блокировки с помощью:
     ```sql
     SELECT * FROM pg_locks;
     SELECT * FROM pg_stat_activity;
     ```

3. **MVCC** гарантирует, что чтения обычно не блокируются записями, а записи — чтениями. При этом «видимость» данных в транзакции определяется снимком (snapshot).

4. **Понимайте логику lazy snapshot creation**: если вы начали транзакцию, но не делали запросов к данным, снимок ещё не создан. Когда первый раз делаете `SELECT/UPDATE`, тогда PostgreSQL делает снимок.

---

## Итог

**PostgreSQL 15** (как и версии 9.6+) даёт мощную модель параллелизма — **MVCC** + гибкие **уровни изоляции**.  
- **Repeatable Read** работает как **Snapshot Isolation** (не видит обновления после первого чтения).  
- **Serializable** обеспечивает иллюзию последовательного выполнения, но при конфликте выдаёт `serialization_failure`.  
- **Блокировки** в основном «строчно-ориентированные» (row-level locks), что повышает конкурентность; а «табличные» используются только для DDL и специальных операций.  
- **Фантомные чтения** в классическом смысле не возникают на уровне Repeatable Read, но в Serializable – могут приводить к ошибке, защищая данные от логических конфликтов.

**Надеюсь, этот отчёт поможет глубже понять, как PostgreSQL управляет параллельным доступом к данным и почему в Repeatable Read и Serializable поведение разное при одинаковых сценариях.**