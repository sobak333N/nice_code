Ниже приведено **очень подробное** описание HTTP-методов и основных принципов REST (Representational State Transfer). 

---

# 1. HTTP-методы

## 1.1. Обзор HTTP

HTTP (HyperText Transfer Protocol) — это протокол прикладного уровня, который лежит в основе взаимодействия клиент–сервер в Сети (в частности, используется для веб-сайтов). Клиент (например, веб-браузер или другое приложение) отправляет запрос, а сервер отвечает, предоставляя запрошенные данные или результат операции.

## 1.2. Основные методы HTTP

### 1.2.1. GET

- **Назначение**: Запросить представление ресурса.  
- **Тело запроса**: Обычно отсутствует или пустое.  
- **Особенности**:  
  - **Безопасен** (не изменяет состояние сервера).  
  - **Идемпотентен**: повторные вызовы GET не изменят состояние сервера.  
  - Используется для получения (чтения) данных.  
  - Параметры часто передаются в URL (Query string).

**Пример**:  
```http
GET /users/123 HTTP/1.1
Host: example.com
```
Сервер вернёт информацию о пользователе с id=123.

---

### 1.2.2. POST

- **Назначение**: Создать ресурс или выполнить процесс на сервере (может быть не только создание).
- **Тело запроса**: Обычно содержит данные (например, JSON, XML, форму).
- **Особенности**:  
  - **Не идемпотентен**: повторный вызов POST может привести к созданию нескольких ресурсов или к другим повторным действиям.  
  - Применяется для отправки данных на сервер, например, при регистрации, создании новых записей.

**Пример**:
```http
POST /users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "Alice",
  "email": "alice@example.com"
}
```
Сервер создаст нового пользователя.

---

### 1.2.3. PUT

- **Назначение**: Полностью заменить (обновить) представление ресурса. Если ресурс не существует, некоторые серверы могут его создать.
- **Тело запроса**: Содержит новые данные целиком.
- **Особенности**:  
  - **Идемпотентен**: повторный вызов PUT с одинаковыми данными приведёт к одному и тому же результату (состояние не будет меняться после первого обновления).  
  - Обычно используется для полной замены ресурса.

**Пример**:
```http
PUT /users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "id": 123,
  "name": "Alice",
  "email": "newalice@example.com"
}
```
Сервер полностью обновит данные пользователя id=123. Если какая-то информация не указана (например, `phone`), считается, что её нет (или сбрасывается).

---

### 1.2.4. PATCH

- **Назначение**: Частичное обновление ресурса (часть полей).  
- **Тело запроса**: Содержит только изменяемые поля, либо специальный формат patch (JSON Patch, Merge Patch).  
- **Особенности**:  
  - **Не всегда идемпотентен** (зависит от того, как написан сервер).  
  - Более точечно обновляет ресурс, не требуя передавать все поля.

**Пример**:
```http
PATCH /users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "email": "patchalice@example.com"
}
```
Сервер обновит только поле `email`.

---

### 1.2.5. DELETE

- **Назначение**: Удалить ресурс.
- **Тело запроса**: Обычно не используется.
- **Особенности**:  
  - **Идемпотентен**: повторный вызов DELETE одного и того же ресурса приведёт к тому, что ресурс будет удалён при первом вызове, а последующие вызовы не изменят состояние (ресурс уже удалён).  
  - Часто используется для деактивации или логического удаления (если физического удаления нет).

**Пример**:
```http
DELETE /users/123 HTTP/1.1
Host: example.com
```
Сервер удалит пользователя c id=123 (или отметит как удалённого).

---

### 1.2.6. Другие методы

- **HEAD**: Аналогичен GET, но сервер не возвращает тело, а только заголовки. Удобен для проверки существования ресурса или метаданных (размер, тип и т. д.).
- **OPTIONS**: Возвращает список поддерживаемых методов и другие параметры взаимодействия с ресурсом (CORS-проверка, предварительный запрос браузером).
- **TRACE**: Диагностический метод, возвращающий клиенту обратный поток запроса (для отладки). Считается небезопасным в продакшене.

---

## 1.3. Свойства некоторых методов

- **Безопасный (Safe)**: GET, HEAD, OPTIONS, TRACE. Эти методы не должны изменять состояние на сервере.
- **Идемпотентный (Idempotent)**: GET, PUT, DELETE, HEAD, OPTIONS, TRACE. Повторный вызов приводит к тому же результату, что и первый, с точки зрения состояния сервера.
- **Неидемпотентный**: POST, (PATCH — зависит от реализации).

---

# 2. Принципы REST

**REST (Representational State Transfer)** — это архитектурный стиль взаимодействия клиент–сервер, предложенный Роем Филдингом. REST не является стандартом, но описывает набор принципов, как должны строиться веб-сервисы (API).

## 2.1. Основные принципы (constraints)

1. **Клиент–сервер (Client–Server)**  
   - Должно быть чёткое разделение на клиент и сервер. Клиент не занимается хранением данных, сервер не занимается отображением UI.

2. **Отсутствие состояния (Stateless)**  
   - Каждый запрос должен содержать всю необходимую информацию для его обработки, сервер не хранит состояние сессии (или минимизирует это).  
   - Если нужно хранить состояние (например, авторизация), обычно используют токены или передачу данных в заголовках.

3. **Кеширование (Cacheable)**  
   - Ответы сервера должны быть помечены как кешируемые или некешируемые.  
   - Если ответ кешируется, то клиент может использовать кеш, не обращаясь заново к серверу.

4. **Единообразие интерфейса (Uniform Interface)**  
   - Использование HTTP-методов по их назначению (GET, POST, PUT, DELETE и т. д.).  
   - Ресурсы должны иметь единый стиль взаимодействия (URI, методы, заголовки, коды ответа).

5. **Слои системы (Layered System)**  
   - Система может состоять из нескольких уровней (прокси, балансировщики, шлюзы и т. д.).  
   - Каждый уровень абстрагирован от других, клиенту не важно, кто именно отвечает (прокси или конечный сервер).

6. **Код по требованию (Code on Demand) (необязательный)**  
   - Сервер может передавать клиенту исполняемый код (например, JavaScript), чтобы расширять возможности клиента.  
   - Этот принцип используют не все REST-сервисы, поэтому считается опциональным.

---

## 2.2. Идентификация ресурсов

В REST каждое понятие (пользователь, статья, сообщение и т. д.) называется ресурсом.  
- Ресурс идентифицируется уникальным URI. Например, `https://api.example.com/users/123`.

---

## 2.3. Манипуляции с ресурсами через представления (Representations)

- Клиент получает представление ресурса (JSON, XML, HTML, CSV и т. д.).  
- При внесении изменений клиент отправляет обновлённое представление на сервер (в JSON, XML и т. д.) с нужным методом HTTP.

---

## 2.4. Самоописательные сообщения

Сообщения (HTTP-запросы и ответы) должны содержать всю необходимую информацию: заголовки `Content-Type`, `Accept`, коды ответа, заголовок `Allow` (для OPTIONS) и т. п.

---

## 2.5. Гипермедиа как движок приложения (HATEOAS)

По этому принципу (не всегда соблюдается на практике), сервер может возвращать в ответе ссылки (hyperlinks), указывающие, какие действия доступны дальше. Например, при запросе `GET /users/123` в JSON может быть поле `_links`, содержащее URL для редактирования, удаления и т. д.

---

# 3. Дополнительные аспекты REST и HTTP

## 3.1. Коды статуса HTTP

Важно не только использовать методы, но и **правильно отправлять коды ответа**:

- `200 OK` — успешный запрос (GET, PATCH и т. д.).
- `201 Created` — успешное создание ресурса (POST).
- `204 No Content` — успешное выполнение без тела ответа (например, DELETE).
- `400 Bad Request` — неверный синтаксис запроса.
- `401 Unauthorized` / `403 Forbidden` — проблемы с авторизацией/доступом.
- `404 Not Found` — ресурс не найден.
- `409 Conflict` — конфликт при создании/обновлении (например, дублирующий ключ).
- `500 Internal Server Error` — внутренняя ошибка сервера.

---

## 3.2. Аутентификация и авторизация

- В REST не предполагается хранение сервером состояния сессии (Stateless).  
- Обычно используют **Bearer Tokens**, **JWT**, **OAuth** или другие механизмы, где клиент передаёт токен в заголовке `Authorization: Bearer <token>`.

---

## 3.3. Фильтрация, пагинация и сортировка

Часто в REST API реализуют возможности для выборки данных:

- **Фильтрация**: `GET /users?role=admin&status=active`
- **Пагинация**: `GET /users?page=2&limit=20`
- **Сортировка**: `GET /users?sort=name_desc`

---

## 3.4. Версионирование

REST API часто версионируют, чтобы не ломать совместимость:  
- В URL: `GET /v1/users` или `GET /v2/users`  
- В заголовках: `Accept: application/json; version=1.0`

---

## 3.5. HAL, JSON:API и другие форматы

Для более строгой структуры и применения HATEOAS используют форматы, например:  
- **HAL (Hypertext Application Language)**  
- **JSON:API**  
Они определяют, как должны выглядеть поля `_links`, `_embedded` и т. п.

---

## 3.6. REST vs. другие стили

- **GraphQL**: запрашивает данные по схеме, выбирая только нужные поля.  
- **gRPC**: использует Protocol Buffers и бинарный протокол, может быть быстрее и легче для некоторых задач.

REST остаётся очень популярным благодаря простоте, использованию HTTP-стека и универсальности.

---

# 4. Резюме

1. **HTTP-методы** дают чёткую семантику:  
   - `GET` для чтения,  
   - `POST` для создания,  
   - `PUT` для полной замены,  
   - `PATCH` для частичного обновления,  
   - `DELETE` для удаления.  

2. **Принципы REST**:  
   - Клиент–сервер,  
   - Без состояния,  
   - Кэширование,  
   - Единообразие интерфейса,  
   - Многоуровневая архитектура,  
   - По требованию (необязательно).  

3. **Ресурсы и URI**: Всё, что мы хотим управлять, — это ресурс, который идентифицируется URI.  

4. **Методы HTTP** и **коды статуса** должны использоваться согласованно, обеспечивая понятный и предсказуемый интерфейс для клиента.  

5. **Расширения**: пагинация, фильтрация, сортировка, аутентификация, версия API, гипермедиа — всё это помогает сделать API более гибким и удобным.

Таким образом, **REST** — это соглашения и лучшие практики, которые вместе с **HTTP-методами** делают API предсказуемыми, понятными и масштабируемыми.