O-Open/closed principle

Классы должны быть открыты для расширения и закрыты для изменений
Это означает, что поведение класса можно изменять 
через расширение (наследование, композицию), не меняя существующий код.

Стабильность кода:
    Избежание изменения рабочего кода снижает вероятность ошибок.
Расширяемость:
    Легко добавлять новые функции или поддерживать новые сценарии, не изменяя уже существующий функционал.
Простота тестирования:
    Когда основной код не меняется, протестированные компоненты остаются стабильными.


Bad practice:
```py
class Weapon:
    def __init__(self, weapon_type: str):
        self.weapon_type = weapon_type

    def attack(self):
        if self.weapon_type == 'gun':
            print("pif paf")
        elif self.weapon_type == 'sword':
            print("bam")
        # Добавляем новый тип оружия:
        elif self.weapon_type == 'bow':
            print("thwip")
```

при добавлении нового типа оружия нам придется изменять уже рабочий метод, 
что может привести к мотенциальным ошибкам

Good practice:
```py
class Weapon:
    def attack(self):
        """Абстрактный метод атаки"""
        pass


class Gun(Weapon):
    def attack(self):
        print("pif paf")


class Sword(Weapon):
    def attack(self):
        print("bam")


class Bow(Weapon):
    def attack(self):
        print("thwip")
```

Таким образом мы расширили существующий класс , не изменяя написанной логики
Чтобы добавить новый тип оружия, нужно создать новый класс, не изменяя существующий код.
Поведение расширяется через наследование.