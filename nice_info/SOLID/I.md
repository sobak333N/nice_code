I-Interface segregation principle
    Принцип разделения интерфейсов

Клиенты(классы) не должны зависеть от интерфейсов, которые не используют

Основная идея:
    Если класс реализует интерфейс или наследуется от абстрактного класса,
    он должен использовать все его методы, которые определены в интерфейсе или
    базовом классе

    Лучше разделить интерфейсы на более мелкие, чтобы каждый класс использовал только те
    интерфейсы, которые ему нужны

Bad practice:
```py
class Machine:
    def print(self, document):
        pass

    def scan(self, document):
        pass

    def fax(self, document):
        pass


class Printer(Machine):
    def print(self, document):
        print("Printing:", document)

    def scan(self, document):
        raise NotImplementedError("Printer does not support scanning")

    def fax(self, document):
        raise NotImplementedError("Printer does not support faxing")
```

Класс Printer вынужден реализовывать методы scan и fax, которые ему не нужны.
Нарушение принципа: Printer зависит от интерфейса, который он не использует


Сравнение с принципом Liskov Substitution Principle (LSP)

    Сходства:
        Оба принципа фокусируются на корректной архитектуре и логической согласованности классов.
        Оба принципа помогают минимизировать избыточность и улучшить расширяемость.

    Различия:

Liskov Substitution (LSP)	                                            Interface Segregation (ISP)
Ориентирован на отношения между базовым и производным классами.	        Ориентирован на проектирование интерфейсов.
Требует, чтобы подклассы могли без проблем заменять базовый класс.	    Требует разделения больших интерфейсов на мелкие.
Нарушение возникает, если подкласс                                      Нарушение возникает, если класс вынужден
изменяет поведение базового класса.	                                    реализовать ненужные методы.