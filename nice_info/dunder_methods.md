Ниже приведён **обзор основных магических (dunder) методов** классов в Python. Эти методы окружены двойными подчёркиваниями (например, `__init__`) и автоматически вызываются интерпретатором Python в различных ситуациях. Реализация магических методов позволяет объектам вашего класса участвовать в операциях (арифметических, логических, сравнениях), определять свое поведение при преобразованиях типов и т. д.

---

## 1. Инициализация и создание объекта

1. **`__new__(cls, *args, **kwargs)`**  
   - Отвечает за **создание** нового объекта класса.
   - Вызывается **до** `__init__`.
   - Редко используется напрямую, полезен в метапрограммировании или при создании **singleton** (или других паттернов).

2. **`__init__(self, *args, **kwargs)`**  
   - Инициализирует объект, уже созданный методом `__new__`.
   - Задает атрибуты экземпляра.
   - Самый часто используемый метод при описании класса.

3. **`__del__(self)`**  
   - Вызывается при **удалении** объекта (когда сборщик мусора освобождает память или при вызове `del obj`).
   - Не рекомендуется полагаться на него для критического освобождения ресурсов; лучше использовать контекстные менеджеры или `weakref`.

---

## 2. Строковое представление объекта

1. **`__str__(self)`**  
   - Определяет «человекочитаемое» строковое представление объекта.
   - Вызывается функцией `str(obj)` или при `print(obj)`.

2. **`__repr__(self)`**  
   - Определяет «программистское» представление объекта.
   - Вызывается функцией `repr(obj)` или при вводе объекта в интерактивном режиме.
   - Идеально, если `eval(repr(obj))` воссоздает объект (но не всегда возможно).

3. **`__format__(self, format_spec)`**  
   - Определяет, как объект форматируется функцией `format(obj, format_spec)` и f-строками (например, `f"{obj:format_spec}"`).
   - Полезно для пользовательского форматирования.

4. **`__bytes__(self)`**  
   - Определяет, что возвращается при вызове `bytes(obj)` (бинарное представление объекта).

---

## 3. Арифметические операции

Эти методы позволяют объектам вашего класса участвовать в арифметических выражениях с операторами `+`, `-`, `*`, `/` и т.д.

### 3.1 Бинарные операции

- **`__add__(self, other)`**: оператор `+` (obj1 + obj2).
- **`__sub__(self, other)`**: оператор `-` (obj1 - obj2).
- **`__mul__(self, other)`**: оператор `*` (obj1 * obj2).
- **`__truediv__(self, other)`**: оператор `/` (obj1 / obj2).
- **`__floordiv__(self, other)`**: оператор `//` (obj1 // obj2).
- **`__mod__(self, other)`**: оператор `%` (obj1 % obj2).
- **`__pow__(self, other)`**: оператор `**` (obj1 ** obj2).

### 3.2 Обратные (r-) методы

Если Python не нашёл подходящий `__add__`, например, в левом операнде, то он вызовет `__radd__` правого операнда. Аналогично для других операций.

- **`__radd__(self, other)`**: оператор `+`, когда левый операнд не поддерживает сложение с `other`.
- **`__rsub__`, `__rmul__`, `__rtruediv__`, и т.д.**

### 3.3 Операции с присваиванием (i-методы)

- **`__iadd__(self, other)`**: оператор `+=`.
- **`__isub__(self, other)`**, `__imul__`, `__itruediv__`, etc.

---

## 4. Логические и сравнения

### 4.1 Сравнение

- **`__eq__(self, other)`**: оператор `==`.
- **`__ne__(self, other)`**: оператор `!=`.
- **`__lt__(self, other)`**: оператор `<`.
- **`__le__(self, other)`**: оператор `<=`.
- **`__gt__(self, other)`**: оператор `>`.
- **`__ge__(self, other)`**: оператор `>=`.

Обычно для полного набора сравнений достаточно переопределить `__eq__` и `__lt__` (например), а остальные могут выводиться автоматически через декоратор `functools.total_ordering`.

### 4.2 Преобразование к булеву типу

- **`__bool__(self)`**: Вызывается при `bool(obj)`, в условных выражениях `if obj:`.  
  Если не определён, Python пытается вызвать `__len__`.

### 4.3 Хэширование

- **`__hash__(self)`**: Возвращает целое число (hash value), используемое в словарях (dict) и множествах (set).  
- Если вы переопределили `__eq__`, желательно переопределить `__hash__`, чтобы сохранить согласованность.

---

## 5. Протокол итераций

1. **`__iter__(self)`**: Должен возвращать **итератор** (обычно возвращает `self`).
2. **`__next__(self)`**: Определяет, что возвращается при каждом шаге итерации. Должен вызвать `raise StopIteration`, когда элементы кончились.

Пример:
```python
class Counter:
    def __init__(self, limit):
        self.limit = limit
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.limit:
            raise StopIteration
        self.current += 1
        return self.current
```

---

## 6. Коллекции и доступ по индексу

1. **`__len__(self)`**: Возвращает длину объекта (например, для `len(obj)`).
2. **`__getitem__(self, key)`**: Оператор `obj[key]`.
3. **`__setitem__(self, key, value)`**: Установка `obj[key] = value`.
4. **`__delitem__(self, key)`**: Удаление элемента `del obj[key]`.
5. **`__contains__(self, item)`**: Оператор `in` (например, `if item in obj:`).

---

## 7. Контекстные менеджеры

- **`__enter__(self)`**: Вызывается при входе в контекст `with`.
- **`__exit__(self, exc_type, exc_val, exc_tb)`**: Вызывается при выходе из контекста, в том числе при исключении.  
Полезно для открытия/закрытия ресурсов (файлы, сетевые соединения).

Пример:
```python
class FileManager:
    def __init__(self, filename):
        self.filename = filename

    def __enter__(self):
        self.file = open(self.filename, 'w')
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()
```

---

## 8. Вызываемые объекты (callable)

- **`__call__(self, *args, **kwargs)`**: Делает экземпляр класса **вызываемым**, как функцию: `obj(...)`.
- Применяется для реализации паттерна «функция-класс» или функциональных объектов.

---

## 9. Управление атрибутами

1. **`__getattr__(self, name)`**: Вызывается, когда атрибут `name` не найден обычным способом.
2. **`__setattr__(self, name, value)`**: Вызывается при установке атрибута `obj.name = value`.
3. **`__delattr__(self, name)`**: Вызывается при удалении атрибута `del obj.name`.
4. **`__getattribute__(self, name)`**: Вызывается **при любом** доступе к атрибуту, всегда (даже если атрибут существует). Требует осторожности, чтобы не вызвать рекурсию.

### 9.1 Дескрипторы

Если ваш класс реализует один из методов `__get__`, `__set__`, `__delete__`, то объекты класса становятся **дескрипторами**. Это позволяет переопределять логику доступа к атрибутам в классе-владельце.

---

## 10. Прочие методы

- **`__index__(self)`**: Позволяет объекту использоваться в срезах (`obj[1:obj2]`), так как Python требует целое число.
- **`__enter__`, `__exit__`** (уже рассмотрено) — контекстный менеджер.
- **`__missing__(self, key)`** в словарях-наследниках (dict), вызывается при попытке доступа к несуществующему ключу.
- **`__bytes__`** (уже упоминалось) для `bytes(obj)`.
- **`__round__(self, n)`**: Вызывается функцией `round(obj, n)`.
- **`__trunc__`, `__floor__`, `__ceil__`**: Для математических операций из модуля `math`.

---

## 11. Итог

Магические методы (**dunder methods**) — это способ «включить» объекты вашего класса в стандартные протоколы Python (итерации, арифметику, сравнения, контекстные менеджеры и т.д.). Правильная реализация магических методов позволяет создавать «нативные» объекты, которые ведут себя как встроенные типы (списки, числа, файлы и т.д.).

**Что помнить:**

1. Не злоупотребляйте магическими методами: пишите их только когда действительно нужна поддержка соответствующего протокола.
2. Соблюдайте **контракты** протокола (например, если переопределили `__eq__`, подумайте о `__hash__`).
3. Используйте магические методы, чтобы ваш код становился более выразительным и «pythonic».

Таким образом, магические методы — это ключ к созданию полноценных типов данных, которые гармонично встраиваются в экосистему Python.






#####
ДАНДЕР МЕТОДЫ КЛАССОВ


Когда мы говорим, что «все классы в Python — это экземпляры `type`», мы имеем в виду, что **сам класс** (как объект) наследуется от метакласса `type`. У `type` есть собственные магические (dunder) методы, которые вызываются во время **создания** или **использования** класса как объекта. Ниже — список основных таких методов с краткими пояснениями.

---

## 1. `__new__` и `__init__` (на уровне метакласса)

### **`type.__new__(mcls, name, bases, namespace, **kwargs)`**
- Вызывается при **создании** нового класса (как объекта).
- Аргументы:
  - `mcls` — сам метакласс, обычно `type`.
  - `name` — имя класса (`"MyClass"`).
  - `bases` — кортеж базовых классов.
  - `namespace` — словарь, содержащий атрибуты (методы, поля), определённые в теле класса.
- Возвращает **объект-класс**.
- Встроенная реализация `type.__new__` создаёт новый объект класса, наделяя его нужными атрибутами.

### **`type.__init__(cls, name, bases, namespace, **kwargs)`**
- Инициализирует уже созданный объект-класс.
- Обычно в реализации встроенного `type` делает дополнительную настройку класса.
- В большинстве случаев унаследованная реализация `type.__init__` ничего особенного не делает, но при переопределении в пользовательском метаклассе можно достраивать класс.

> **Замечание**: Когда вы объявляете класс:
> ```python
> class MyClass(Base):
>     attr = ...
>     def method(self): ...
> ```
> под капотом происходит вызов `type.__new__` (через `type(name, bases, namespace)`), затем `type.__init__`.

---

## 2. `__call__`

### **`type.__call__(cls, *args, **kwargs)`**
- Определяет, что происходит при **вызове** объекта-класса как функции: `MyClass(...)`.
- На уровне `type`, этот метод создаёт **экземпляр** (instance) класса, вызывая:
  1. `cls.__new__(...)` экземпляра
  2. `cls.__init__(...)` экземпляра
- То есть `type.__call__` — это «конструктор» экземпляров класса (то, что создаёт `obj = MyClass(...)`).

> Аналогично тому, как у обычного класса `__call__` делает объект вызываемым, у метакласса `__call__` делает класс «вызываемым» для создания инстансов.

---

## 3. `__prepare__` (Python 3)

### **`type.__prepare__(name, bases, **kwargs)`**
- Введён в Python 3 для расширенных возможностей метапрограммирования.
- Если у метакласса объявлен метод `__prepare__`, то при создании класса сначала вызывается он, чтобы получить **пространство имён** (namespace), в котором будет выполняться тело класса.
- По умолчанию возвращается обычный `dict`.
- Можно вернуть **упорядоченный словарь** или другой контейнер, чтобы перехватывать порядок определения методов и атрибутов в классе и т. д.

> Пример использования — OrderedDict, чтобы класс «запоминал» порядок объявления своих атрибутов.

---

## 4. Проверки наследования и экземпляров

### **`__instancecheck__(cls, instance)`**
- Вызывается при `isinstance(instance, cls)`.
- Встроенная реализация проверяет, принадлежит ли `instance.__class__` (или его предки) классу `cls`.

### **`__subclasscheck__(cls, subclass)`**
- Вызывается при `issubclass(subclass, cls)`.
- Встроенная реализация смотрит на иерархию базовых классов `subclass`.

> Если писать собственный метакласс, можно переопределить эти методы, чтобы «обмануть» или уточнить логику `isinstance`/`issubclass`.

---

## 5. Другие служебные атрибуты класса

Хотя это не всегда «методы», класс как объект (экземпляр `type`) имеет множество служебных dunder-атрибутов, отнаследованных от `object` и самого `type`. Некоторые из них:

- **`__name__`**: строка, имя класса (например, `"MyClass"`).
- **`__qualname__`**: квалифицированное имя, учитывающее вложенность (Python 3.3+).
- **`__module__`**: модуль, в котором определён класс.
- **`__dict__`**: словарь атрибутов класса.
- **`__bases__`**: кортеж базовых классов (например, `(BaseClass, )`).
- **`__mro__`**: Method Resolution Order — кортеж, описывающий порядок поиска атрибутов.
- **`__subclasses__()`**: метод, возвращающий список прямых подклассов.

---

## 6. Итог

Когда вы объявляете класс `class MyClass: ...`, Python под капотом:

1. Вызывает (на уровне метакласса) `__prepare__`, чтобы создать пространство имён для тела класса.
2. Выполняет код тела класса в этом пространстве имён (создаются функции, переменные).
3. Вызывает `type.__new__` (или другой метакласс, если указан `metaclass=...`) с аргументами `(name, bases, namespace)`, получая объект-класс.
4. Затем `type.__init__`, если оно переопределено.

У уже готового класса есть такие методы `__call__`, `__instancecheck__`, `__subclasscheck__` и атрибуты вроде `__name__`, `__bases__` и т. д. Это всё идёт от метакласса `type`.

Таким образом, **«дандер»-методы на уровне класса** — это методы метакласса `type`, которые управляют созданием и поведением самого класса как объекта, в отличие от дандер-методов уровня экземпляра, которые управляют поведением объектов пользователя.